<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pembelajaran Bilangan Bulat</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <h1>Pembelajaran Bilangan Bulat</h1>
        <div class="input-group">
            <input type="number" id="num1" placeholder="Angka pertama" oninput="startAnimation()">
            <select id="operator" oninput="startAnimation()">
                <option value="+">+</option>
                <option value="-">−</option>
            </select>
            <input type="number" id="num2" placeholder="Angka kedua" oninput="startAnimation()">
        </div>
        <canvas id="garis" width="700" height="200"></canvas>
        <p id="hasil"></p>
    </div>

    <script>
        const canvas = document.getElementById("garis");
        const ctx = canvas.getContext("2d");
        let animationFrameId;
        const padding = 60; // Declare padding globally

        // Create tooltip element
        const tooltip = document.createElement("div");
        tooltip.className = "tooltip";
        document.body.appendChild(tooltip);

        function drawNumberLine(minVal, maxVal, num1, num2, result) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Calculate canvas dimensions
            const canvasWidth = canvas.width - 2 * padding;

            // Create custom tick array based on num1, num2, and result
            const ticks = [];
            ticks.push(0); // Always include zero
            ticks.push(num1); // Include first input

            // Define fineStart and fineEnd outside conditional blocks
            const fineStart = result - 3;
            const fineEnd = result + 3;

            // Add consecutive ticks leading to result for addition
            if (operator === '+') {
                const start = Math.min(num1, result);
                const end = Math.max(num1, result);
                for (let i = start; i <= end; i++) {
                    ticks.push(i);
                }
                // Add finer ticks near result
                for (let i = fineStart; i <= fineEnd; i++) {
                    ticks.push(i);
                }
            } else {
                if (Math.abs(result) <= 10) {
                    // For small results, use linear ticks
                    const tickInterval = Math.max(1, Math.ceil((maxVal - minVal) / 10));
                    for (let i = Math.floor(minVal); i <= Math.ceil(maxVal); i += tickInterval) {
                        ticks.push(i);
                    }
                } else {
                    // Add more intermediate points based on num1 and num2
                    if (num2 !== 0) {
                        const numIntermediate = 7; // Increased for denser progression
                        const step = (result - num1) / (numIntermediate + 1);
                        for (let i = 1; i <= numIntermediate; i++) {
                            ticks.push(Math.round(num1 + step * i));
                        }
                    }
                    // Add finer ticks near the result
                    for (let i = fineStart; i <= fineEnd; i++) {
                        if (i !== result) ticks.push(i); // Avoid duplicate result
                    }
                }
            }

            // Ensure result is always included
            ticks.push(result);
            // Add one tick after the result
            ticks.push(result >= 0 ? result + 1 : result - 1);

            // Ensure unique and sorted ticks
            const uniqueTicks = [...new Set(ticks)].sort((a, b) => a - b);

            // Map ticks to evenly spaced positions
            const tickSpacing = canvasWidth / (uniqueTicks.length - 1);

            // Store tick positions for animation
            const tickPositions = new Map();
            uniqueTicks.forEach((tick, index) => {
                const x = padding + index * tickSpacing;
                tickPositions.set(tick, x);
            });

            // Draw number line with shadow
            ctx.beginPath();
            ctx.moveTo(padding, 100);
            ctx.lineTo(canvas.width - padding, 100);
            ctx.strokeStyle = "#1a3c6d";
            ctx.lineWidth = 4;
            ctx.shadowColor = "rgba(0, 0, 0, 0.2)";
            ctx.shadowBlur = 5;
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Draw ticks and labels
            ctx.font = "16px 'Segoe UI', Arial";
            ctx.fillStyle = "#1a3c6d";
            ctx.textAlign = "center";
            uniqueTicks.forEach((tick, index) => {
                const x = padding + index * tickSpacing;
                if (x >= padding - 10 && x <= canvas.width - padding + 10) {
                    ctx.beginPath();
                    ctx.moveTo(x, 95);
                    ctx.lineTo(x, 105);
                    ctx.strokeStyle = "#1a3c6d";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.fillText(tick, x, 125);
                }
            });

            // Draw arrowheads
            ctx.beginPath();
            ctx.moveTo(canvas.width - padding, 100);
            ctx.lineTo(canvas.width - padding - 8, 92);
            ctx.moveTo(canvas.width - padding, 100);
            ctx.lineTo(canvas.width - padding - 8, 108);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(padding, 100);
            ctx.lineTo(padding + 8, 92);
            ctx.moveTo(padding, 100);
            ctx.lineTo(padding + 8, 108);
            ctx.stroke();

            return { tickPositions, uniqueTicks };
        }

        function drawArrowhead(x, y, direction, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x, y);
            if (direction === "right") {
                ctx.lineTo(x - 8, y - 8);
                ctx.lineTo(x - 8, y + 8);
            } else {
                ctx.lineTo(x + 8, y - 8);
                ctx.lineTo(x + 8, y + 8);
            }
            ctx.fill();
        }

        function drawResultMarker(x, y, result) {
            // Draw a dot on the number line
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, 2 * Math.PI);
            ctx.fillStyle = "#2ecc71";
            ctx.fill();
            ctx.strokeStyle = "#1a3c6d";
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // Handle tooltip on hover
        let resultX, resultY, resultValue;
        canvas.addEventListener("mousemove", (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (resultX && Math.hypot(mouseX - resultX, mouseY - resultY) < 10) {
                tooltip.style.left = `${e.clientX + 10}px`;
                tooltip.style.top = `${e.clientY - 10}px`;
                tooltip.textContent = resultValue;
                tooltip.style.opacity = "1";
            } else {
                tooltip.style.opacity = "0";
            }
        });

        canvas.addEventListener("mouseleave", () => {
            tooltip.style.opacity = "0";
        });

        // Initial draw
        drawNumberLine(-10, 10, 0, 0, 0);

        function startAnimation() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            const num1 = parseInt(document.getElementById("num1").value) || 0;
            const num2 = parseInt(document.getElementById("num2").value) || 0;
            const operator = document.getElementById("operator").value;
            const hasil = operator === '+' ? num1 + num2 : num1 - num2;

            // Store result for tooltip
            resultValue = hasil;

            // Determine min and max values
            const values = [0, num1, hasil];
            const minVal = Math.min(...values) - 3;
            const maxVal = Math.max(...values) + 3;

            const { tickPositions, uniqueTicks } = drawNumberLine(minVal, maxVal, num1, num2, hasil);

            // Ensure tickPositions contains the correct coordinates
            const startX = tickPositions.get(0) || padding;
            const targetMidX = tickPositions.get(num1) || (num1 >= 0 ? padding : canvas.width - padding);
            let targetEndX = tickPositions.get(hasil);

            // Interpolate if hasil is not an exact tick
            if (targetEndX === undefined) {
                const sortedTicks = [...uniqueTicks].sort((a, b) => a - b);
                const index = sortedTicks.findIndex(tick => tick >= hasil);
                if (index === -1) index = sortedTicks.length - 1; // If hasil is beyond max tick
                const prevTick = sortedTicks[index - 1] || sortedTicks[0];
                const nextTick = sortedTicks[index];
                const prevX = tickPositions.get(prevTick) || padding;
                const nextX = tickPositions.get(nextTick) || (nextTick >= 0 ? canvas.width - padding : padding);

                // Linear interpolation
                const ratio = (hasil - prevTick) / (nextTick - prevTick);
                targetEndX = prevX + (nextX - prevX) * ratio;
            }

            let currentX = startX;
            let midXReached = false;
            const animationDuration = 1000;
            let startTime;

            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = (timestamp - startTime) / animationDuration;

                drawNumberLine(minVal, maxVal, num1, num2, hasil);

                if (!midXReached) {
                    currentX = startX + (targetMidX - startX) * Math.min(progress, 1);
                    ctx.strokeStyle = "#4a90e2";
                    ctx.lineWidth = 4;
                    ctx.shadowColor = "rgba(0, 0, 0, 0.2)";
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    ctx.moveTo(startX, 60);
                    ctx.lineTo(currentX, 60);
                    ctx.setLineDash([8, 8]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.shadowBlur = 0;

                    const num1Direction = num1 >= 0 ? "right" : "left";
                    drawArrowhead(currentX, 60, num1Direction, "#4a90e2");

                    if (progress >= 1) {
                        midXReached = true;
                        startTime = timestamp;
                        currentX = targetMidX;
                    }
                } else {
                    const secondProgress = (timestamp - startTime) / animationDuration;
                    currentX = targetMidX + (targetEndX - targetMidX) * Math.min(secondProgress, 1);

                    ctx.strokeStyle = "#4a90e2";
                    ctx.lineWidth = 4;
                    ctx.shadowColor = "rgba(0, 0, 0, 0.2)";
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    ctx.moveTo(startX, 60);
                    ctx.lineTo(targetMidX, 60);
                    ctx.setLineDash([8, 8]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.shadowBlur = 0;

                    const num1Direction = num1 >= 0 ? "right" : "left";
                    drawArrowhead(targetMidX, 60, num1Direction, "#4a90e2");

                    ctx.strokeStyle = "#e94e4e";
                    ctx.lineWidth = 4;
                    ctx.shadowColor = "rgba(0, 0, 0, 0.2)";
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    ctx.moveTo(targetMidX, 80);
                    ctx.lineTo(currentX, 80);
                    ctx.setLineDash([8, 8]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.shadowBlur = 0;

                    const num2Direction = (operator === '+' ? num2 : -num2) >= 0 ? "right" : "left";
                    drawArrowhead(currentX, 80, num2Direction, "#e94e4e");

                    const hasilElement = document.getElementById("hasil");
                    hasilElement.textContent = `Hasil: ${hasil}`;
                    hasilElement.classList.add("updated");
                    setTimeout(() => hasilElement.classList.remove("updated"), 300);

                    if (secondProgress >= 1) {
                        resultX = targetEndX;
                        resultY = 100;
                        drawResultMarker(targetEndX, 100, hasil);
                        return;
                    }
                }

                animationFrameId = requestAnimationFrame(animate);
            }

            animationFrameId = requestAnimationFrame(animate);
        }
    </script>
    <footer>
        <p>© 2025 Erly. All rights reserved.</p>
    </footer>
</html>