<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pembelajaran Bilangan Bulat</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <h1>Pembelajaran Bilangan Bulat</h1>
        <div class="input-group">
            <input type="number" id="num1" placeholder="Angka pertama" oninput="startAnimation()">
            <select id="operator" oninput="startAnimation()">
                <option value="+">+</option>
                <option value="-">−</option>
            </select>
            <input type="number" id="num2" placeholder="Angka kedua" oninput="startAnimation()">
        </div>
        <canvas id="garis" width="700" height="200"></canvas>
        <p id="hasil"></p>
    </div>

    <script>
        const canvas = document.getElementById("garis");
        const ctx = canvas.getContext("2d");
        let animationFrameId;

        function drawNumberLine(minVal, maxVal) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Calculate scale with extra padding
            const padding = 60;
            const canvasWidth = canvas.width - 2 * padding;
            const range = Math.max(Math.abs(maxVal - minVal), 1);
            const scale = canvasWidth / (range + 4);

            // Adjust minVal and maxVal for integer ticks
            const tickInterval = Math.max(1, Math.ceil(range / 8));
            const adjustedMin = Math.floor(minVal / tickInterval) * tickInterval - tickInterval;
            const adjustedMax = Math.ceil(maxVal / tickInterval) * tickInterval + tickInterval;

            // Draw number line
            ctx.beginPath();
            ctx.moveTo(padding, 100);
            ctx.lineTo(canvas.width - padding, 100);
            ctx.strokeStyle = "#1a3c6d";
            ctx.lineWidth = 4;
            ctx.stroke();

            // Draw ticks and labels
            ctx.font = "16px 'Segoe UI', Arial";
            ctx.fillStyle = "#1a3c6d";
            ctx.textAlign = "center";
            for (let i = adjustedMin; i <= adjustedMax; i += tickInterval) {
                const x = padding + (i - minVal) * scale;
                if (x >= padding - 10 && x <= canvas.width - padding + 10) {
                    ctx.beginPath();
                    ctx.moveTo(x, 95);
                    ctx.lineTo(x, 105);
                    ctx.strokeStyle = "#1a3c6d";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.fillText(i, x, 125);
                }
            }

            // Draw arrowheads
            ctx.beginPath();
            ctx.moveTo(canvas.width - padding, 100);
            ctx.lineTo(canvas.width - padding - 8, 92);
            ctx.moveTo(canvas.width - padding, 100);
            ctx.lineTo(canvas.width - padding - 8, 108);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(padding, 100);
            ctx.lineTo(padding + 8, 92);
            ctx.moveTo(padding, 100);
            ctx.lineTo(padding + 8, 108);
            ctx.stroke();

            return scale;
        }

        function drawArrowhead(x, y, direction, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x, y);
            if (direction === "right") {
                ctx.lineTo(x - 8, y - 8);
                ctx.lineTo(x - 8, y + 8);
            } else {
                ctx.lineTo(x + 8, y - 8);
                ctx.lineTo(x + 8, y + 8);
            }
            ctx.fill();
        }

        function drawResultMarker(x, y, result) {
            // Draw a dot on the number line
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, 2 * Math.PI);
            ctx.fillStyle = "#2ecc71";
            ctx.fill();
            ctx.strokeStyle = "#1a3c6d";
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw result label further below to avoid tick label overlap
            ctx.font = "18px 'Segoe UI', Arial";
            ctx.fillStyle = "#2ecc71";
            ctx.textAlign = "center";
            ctx.fillText(result, x, y + 40); // Moved further down to y=140
        }

        // Initial draw
        drawNumberLine(-10, 10);

        function startAnimation() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            const num1 = parseInt(document.getElementById("num1").value) || 0;
            const num2 = parseInt(document.getElementById("num2").value) || 0;
            const operator = document.getElementById("operator").value;
            const hasil = operator === '+' ? num1 + num2 : num1 - num2;

            // Determine min and max values
            const values = [0, num1, hasil];
            const minVal = Math.min(...values) - 3;
            const maxVal = Math.max(...values) + 3;

            const scale = drawNumberLine(minVal, maxVal);
            const padding = 60;

            const startX = padding + (0 - minVal) * scale;
            const targetMidX = padding + (num1 - minVal) * scale;
            const targetEndX = padding + (hasil - minVal) * scale;

            let currentX = startX;
            let midXReached = false;
            const animationDuration = 1000;
            let startTime;

            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = (timestamp - startTime) / animationDuration;

                drawNumberLine(minVal, maxVal);

                if (!midXReached) {
                    currentX = startX + (targetMidX - startX) * Math.min(progress, 1);
                    ctx.strokeStyle = "#4a90e2";
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(startX, 60);
                    ctx.lineTo(currentX, 60);
                    ctx.setLineDash([8, 8]);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    const num1Direction = num1 >= 0 ? "right" : "left";
                    drawArrowhead(currentX, 60, num1Direction, "#4a90e2");

                    if (progress >= 1) {
                        midXReached = true;
                        startTime = timestamp;
                        currentX = targetMidX;
                    }
                } else {
                    const secondProgress = (timestamp - startTime) / animationDuration;
                    currentX = targetMidX + (targetEndX - targetMidX) * Math.min(secondProgress, 1);

                    ctx.strokeStyle = "#4a90e2";
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(startX, 60);
                    ctx.lineTo(targetMidX, 60);
                    ctx.setLineDash([8, 8]);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    const num1Direction = num1 >= 0 ? "right" : "left";
                    drawArrowhead(targetMidX, 60, num1Direction, "#4a90e2");

                    ctx.strokeStyle = "#e94e4e";
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(targetMidX, 80);
                    ctx.lineTo(currentX, 80);
                    ctx.setLineDash([8, 8]);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    const num2Direction = (operator === '+' ? num2 : -num2) >= 0 ? "right" : "left";
                    drawArrowhead(currentX, 80, num2Direction, "#e94e4e");

                    const hasilElement = document.getElementById("hasil");
                    hasilElement.textContent = `Hasil: ${hasil}`;
                    hasilElement.classList.add("updated");
                    setTimeout(() => hasilElement.classList.remove("updated"), 300);

                    if (secondProgress >= 1) {
                        drawResultMarker(targetEndX, 100, hasil);
                        return;
                    }
                }

                animationFrameId = requestAnimationFrame(animate);
            }

            animationFrameId = requestAnimationFrame(animate);
        }
    </script>
</body>
<footer>
    <p>© 2025 Erly. All rights reserved.</p>
</footer>
</html>