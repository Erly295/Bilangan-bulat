<!DOCTYPE html>
<html lang="id">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pengurangan Bilangan Bulat üå∏‚ú®</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Quicksand:wght@400;500;600;700&display=swap");
    </style>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <nav class="navbar navbar-expand-lg">
      <div class="container-fluid">
        <a class="navbar-brand" href="#">Pembelajaran Bilangan Bulat</a>
        <button
          class="navbar-toggler"
          type="button"
          data-bs-toggle="collapse"
          data-bs-target="#navbarNav"
          style="background: white; border-radius: 15px"
        >
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
          <ul class="navbar-nav ms-auto">
            <li class="nav-item">
              <a class="nav-link" href="index.html" data-transition="fade"
                >‚ûï Penjumlahan</a
              >
            </li>
            <li class="nav-item">
              <a
                class="nav-link active"
                href="pengurangan.html"
                data-transition="fade"
                >‚ûñ Pengurangan</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link" href="perkalian.html" data-transition="fade"
                >‚úñÔ∏è Perkalian</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link" href="pembagian.html">‚ûó Pembagian</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="Interaktif1.html"
                >üß© Interaktif Penjumlahan dan Pengurangan</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link" href="Interaktif2.html"
                >üïπÔ∏è Interaktif Perkalian</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link" href="Interaktif4.html"
                >üß© Interaktif Pembagian</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link" href="game.html" data-transition="fade"
                >üéÆ Permainan</a
              >
            </li>
          </ul>
        </div>
      </div>
    </nav>

    <div class="container my-5 content">
      <div class="text-center">
        <h1>Pengurangan Bilangan Bulat</h1>
      </div>

      <div class="input-group justify-content-center mb-4">
        <input
          type="number"
          id="num1"
          placeholder="Angka Pertama"
          class="form-control w-auto me-2"
          oninput="startAnimation()"
          style="max-width: 200px"
        />
        <div class="operator-box">‚àí</div>
        <input
          type="number"
          id="num2"
          placeholder="Angka Kedua"
          class="form-control w-auto me-2"
          oninput="startAnimation()"
          style="max-width: 200px"
        />
        <button
          class="btn btn-info rounded-circle d-flex align-items-center justify-content-center"
          onclick="showInstructions()"
          title="Petunjuk"
          style="width: 50px; height: 50px"
        >
          üí°
        </button>
      </div>

      <div class="card canvas-card mb-4">
        <div class="card-body p-0">
          <canvas id="garis" width="700" height="250"></canvas>
        </div>
      </div>

      <div
        id="hasil"
        class="alert alert-success text-center result-alert"
        role="alert"
        style="display: none"
      ></div>
    </div>

    <div id="instructionModal" class="modal fade" tabindex="-1">
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title">Penjelasan</h5>
            <button
              type="button"
              class="btn-close"
              data-bs-dismiss="modal"
            ></button>
          </div>
          <div class="modal-body">
            <p>
              <b>Angka Pertama</b><br />
              Menentukan titik awal pada garis bilangan.<br />
              ‚Ä¢ Jika positif (+), bergerak ke kanan dari 0<br />
              ‚Ä¢ Jika negatif (-), bergerak ke kiri dari 0<br /><br />

              <b>Angka Kedua</b><br />
              Menentukan langkah berikutnya:<br />
              ‚Ä¢ Jika positif (+), bergerak ke kiri dari angka pertama<br />
              ‚Ä¢ Jika negatif (-), bergerak ke kanan dari angka pertama<br /><br />

              <b>Note</b><br />
              Misalkan a adalah bilangan bulat, maka -(-a) = a
            </p>
          </div>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
      const canvas = document.getElementById("garis");
      const ctx = canvas.getContext("2d");
      const hasilDiv = document.getElementById("hasil");
      let animationFrameId;
      const padding = 60;

      // Create tooltip element
      const tooltip = document.createElement("div");
      tooltip.className = "tooltip";
      tooltip.style.cssText =
        "position: absolute; background: linear-gradient(135deg, #9F7AEA, #805AD5); color: white; padding: 8px 15px; border-radius: 15px; font-size: 14px; font-weight: 600; pointer-events: none; opacity: 0; transition: opacity 0.2s; z-index: 9999; box-shadow: 0 4px 12px rgba(128, 90, 213, 0.4);";
      document.body.appendChild(tooltip);

      // Responsive canvas
      function resizeCanvas() {
        const container = canvas.parentElement;
        canvas.width = container.offsetWidth - 40;
        canvas.height = 250;
        if (
          document.getElementById("num1").value ||
          document.getElementById("num2").value
        ) {
          startAnimation();
        }
      }

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      function drawNumberLine(minVal, maxVal, num1, num2, result) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const canvasWidth = canvas.width - 2 * padding;
        const ticks = [];

        // Always include 0, num1, and result
        ticks.push(0);
        ticks.push(num1);
        ticks.push(result);

        // Determine if we need to show detailed ticks around result
        const distanceFromNum1ToResult = Math.abs(result - num1);

        // Fine detail around result (always show ¬±3 around result)
        const fineStart = result - 3;
        const fineEnd = result + 3;
        for (let i = fineStart; i <= fineEnd; i++) {
          ticks.push(i);
        }

        // If distance is large, add intermediate milestones but skip numbers between num1 and result
        if (distanceFromNum1ToResult > 10) {
          // Add strategic points between 0 and num1 (if num1 is far from 0)
          if (Math.abs(num1) > 10) {
            const step1 = Math.ceil(Math.abs(num1) / 5);
            const direction1 = num1 > 0 ? 1 : -1;
            for (let i = step1; Math.abs(i) < Math.abs(num1); i += step1) {
              ticks.push(i * direction1);
            }
          }
        } else {
          // If distance is small (‚â§10), show all integers between num1 and result
          const start = Math.min(num1, result);
          const end = Math.max(num1, result);
          for (let i = start; i <= end; i++) {
            ticks.push(i);
          }
        }

        // Add buffer points for better visualization
        const allValues = [0, num1, result];
        const minValue = Math.min(...allValues);
        const maxValue = Math.max(...allValues);

        // Add edge points
        if (minValue < -3) {
          ticks.push(minValue - 2);
        }
        if (maxValue > 3) {
          ticks.push(maxValue + 2);
        }

        const uniqueTicks = [...new Set(ticks)].sort((a, b) => a - b);
        const tickSpacing = canvasWidth / (uniqueTicks.length - 1);

        const tickPositions = new Map();
        uniqueTicks.forEach((tick, index) => {
          const x = padding + index * tickSpacing;
          tickPositions.set(tick, x);
        });

        // Draw main gradient line
        const gradient = ctx.createLinearGradient(
          padding,
          100,
          canvas.width - padding,
          100
        );
        gradient.addColorStop(0, "#B794F4");
        gradient.addColorStop(0.5, "#9F7AEA");
        gradient.addColorStop(1, "#B794F4");

        ctx.strokeStyle = gradient;
        ctx.lineWidth = 4;
        ctx.lineCap = "round";
        ctx.shadowColor = "rgba(159, 122, 234, 0.3)";
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.moveTo(padding, 100);
        ctx.lineTo(canvas.width - padding, 100);
        ctx.stroke();
        ctx.shadowBlur = 0;

        // Draw ticks and numbers
        ctx.font = "bold 14px Quicksand";
        ctx.fillStyle = "#9F7AEA";
        ctx.textAlign = "center";

        uniqueTicks.forEach((tick, index) => {
          const x = padding + index * tickSpacing;
          if (x >= padding - 10 && x <= canvas.width - padding + 10) {
            // Determine tick importance for styling
            const isZero = tick === 0;
            const isNum1 = tick === num1;
            const isResult = tick === result;
            const isNearResult = Math.abs(tick - result) <= 3;

            // Special styling based on importance
            if (isZero) {
              ctx.strokeStyle = "#9F7AEA";
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.moveTo(x, 85);
              ctx.lineTo(x, 115);
              ctx.stroke();
              ctx.fillStyle = "#6B46C1";
              ctx.font = "bold 18px Quicksand";
              ctx.fillText("0", x, 135);
              ctx.font = "bold 14px Quicksand";
            } else if (isNum1 || isResult) {
              // Important points (num1 and result)
              ctx.strokeStyle = "#B794F4";
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.moveTo(x, 88);
              ctx.lineTo(x, 112);
              ctx.stroke();
              ctx.fillStyle = "#805AD5";
              ctx.font = "bold 16px Quicksand";
              ctx.fillText(tick, x, 135);
              ctx.font = "bold 14px Quicksand";
            } else if (isNearResult) {
              // Near result points
              ctx.strokeStyle = "#D4B5F0";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(x, 93);
              ctx.lineTo(x, 107);
              ctx.stroke();
              ctx.fillStyle = "#9F7AEA";
              ctx.fillText(tick, x, 135);
            } else {
              // Milestone points (far from result)
              ctx.strokeStyle = "#E9D8FD";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(x, 95);
              ctx.lineTo(x, 105);
              ctx.stroke();
              ctx.fillStyle = "#C4B5D4";
              ctx.font = "bold 12px Quicksand";
              ctx.fillText(tick, x, 135);
              ctx.font = "bold 14px Quicksand";
            }
          }
        });

        // Draw arrow heads at ends
        drawArrowhead(canvas.width - padding, 100, "right", "#9F7AEA");
        drawArrowhead(padding, 100, "left", "#9F7AEA");

        return { tickPositions, uniqueTicks };
      }

      function drawArrowhead(x, y, direction, color) {
        ctx.fillStyle = color;
        ctx.shadowColor = "rgba(159, 122, 234, 0.3)";
        ctx.shadowBlur = 5;
        ctx.beginPath();
        ctx.moveTo(x, y);
        if (direction === "right") {
          ctx.lineTo(x - 10, y - 8);
          ctx.lineTo(x - 10, y + 8);
        } else {
          ctx.lineTo(x + 10, y - 8);
          ctx.lineTo(x + 10, y + 8);
        }
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      function drawResultMarker(x, y, result) {
        ctx.shadowColor = "rgba(107, 70, 193, 0.5)";
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(x, y, 10, 0, 2 * Math.PI);
        ctx.fillStyle = "#6B46C1";
        ctx.fill();
        ctx.shadowBlur = 0;

        // Inner highlight
        ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
        ctx.beginPath();
        ctx.arc(x - 3, y - 3, 4, 0, Math.PI * 2);
        ctx.fill();
      }

      let resultX, resultY, resultValue;

      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        if (resultX && Math.hypot(mouseX - resultX, mouseY - resultY) < 15) {
          tooltip.style.left = `${e.clientX + 10}px`;
          tooltip.style.top = `${e.clientY - 10}px`;
          tooltip.textContent = `Hasil: ${resultValue} ‚ú®`;
          tooltip.style.opacity = "1";
        } else {
          tooltip.style.opacity = "0";
        }
      });

      canvas.addEventListener("mouseleave", () => {
        tooltip.style.opacity = "0";
      });

      function startAnimation() {
        if (animationFrameId) cancelAnimationFrame(animationFrameId);

        const num1 = parseInt(document.getElementById("num1").value) || 0;
        const num2 = parseInt(document.getElementById("num2").value) || 0;
        const hasil = num1 - num2; // PENGURANGAN

        resultValue = hasil;

        const values = [0, num1, hasil];
        const minVal = Math.min(...values) - 3;
        const maxVal = Math.max(...values) + 3;

        const { tickPositions, uniqueTicks } = drawNumberLine(
          minVal,
          maxVal,
          num1,
          num2,
          hasil
        );

        const startX = tickPositions.get(0) || padding;
        const targetMidX =
          tickPositions.get(num1) ||
          (num1 >= 0 ? padding : canvas.width - padding);
        let targetEndX = tickPositions.get(hasil);

        if (targetEndX === undefined) {
          const sortedTicks = [...uniqueTicks].sort((a, b) => a - b);
          const index = sortedTicks.findIndex((tick) => tick >= hasil);
          const prevTick = sortedTicks[index - 1] || sortedTicks[0];
          const nextTick =
            sortedTicks[index] || sortedTicks[sortedTicks.length - 1];
          const prevX = tickPositions.get(prevTick) || padding;
          const nextX =
            tickPositions.get(nextTick) ||
            (nextTick >= 0 ? canvas.width - padding : padding);
          const ratio = (hasil - prevTick) / (nextTick - prevTick) || 1;
          targetEndX = prevX + (nextX - prevX) * ratio;
        }

        let currentX = startX;
        let midXReached = false;
        const animationDuration = 1200;
        let startTime;

        function animate(timestamp) {
          if (!startTime) startTime = timestamp;
          const progress = (timestamp - startTime) / animationDuration;

          drawNumberLine(minVal, maxVal, num1, num2, hasil);

          if (!midXReached) {
            currentX = startX + (targetMidX - startX) * Math.min(progress, 1);

            // First arrow (num1)
            ctx.strokeStyle = "#B794F4";
            ctx.lineWidth = 5;
            ctx.shadowColor = "rgba(183, 148, 244, 0.4)";
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(startX, 60);
            ctx.lineTo(currentX, 60);
            ctx.setLineDash([10, 8]);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.shadowBlur = 0;

            // Label for num1
            ctx.font = "bold 16px Quicksand";
            ctx.fillStyle = "#B794F4";
            ctx.textAlign = "center";
            const labelX1 = (startX + currentX) / 2;
            const labelY1 = 60 - 18;

            // Background bubble
            const text1 = num1.toString();
            const textWidth1 = ctx.measureText(text1).width;
            ctx.fillStyle = "white";
            ctx.strokeStyle = "#B794F4";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.roundRect(
              labelX1 - textWidth1 / 2 - 10,
              labelY1 - 18,
              textWidth1 + 20,
              28,
              14
            );
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = "#B794F4";
            ctx.fillText(text1, labelX1, labelY1);

            const num1Direction = num1 >= 0 ? "right" : "left";
            drawArrowhead(currentX, 60, num1Direction, "#B794F4");

            if (progress >= 1) {
              midXReached = true;
              startTime = timestamp;
              currentX = targetMidX;
            }
          } else {
            const secondProgress = (timestamp - startTime) / animationDuration;
            currentX =
              targetMidX +
              (targetEndX - targetMidX) * Math.min(secondProgress, 1);

            // First arrow stays
            ctx.strokeStyle = "#B794F4";
            ctx.lineWidth = 5;
            ctx.shadowColor = "rgba(183, 148, 244, 0.4)";
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(startX, 60);
            ctx.lineTo(targetMidX, 60);
            ctx.setLineDash([10, 8]);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.shadowBlur = 0;

            ctx.font = "bold 16px Quicksand";
            ctx.fillStyle = "#B794F4";
            ctx.textAlign = "center";
            const labelX1 = (startX + targetMidX) / 2;
            const labelY1 = 60 - 18;

            const text1 = num1.toString();
            const textWidth1 = ctx.measureText(text1).width;
            ctx.fillStyle = "white";
            ctx.strokeStyle = "#B794F4";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.roundRect(
              labelX1 - textWidth1 / 2 - 10,
              labelY1 - 18,
              textWidth1 + 20,
              28,
              14
            );
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = "#B794F4";
            ctx.fillText(text1, labelX1, labelY1);

            const num1Direction = num1 >= 0 ? "right" : "left";
            drawArrowhead(targetMidX, 60, num1Direction, "#B794F4");

            // Second arrow (SUBTRACTION: negative num2 means opposite direction)
            // Subtracting positive = move left, subtracting negative = move right
            const effectiveMovement = -num2; // Pengurangan membalik arah
            const arrowColor = effectiveMovement >= 0 ? "#10B981" : "#EF4444";

            ctx.strokeStyle = arrowColor;
            ctx.lineWidth = 5;
            ctx.shadowColor =
              effectiveMovement >= 0
                ? "rgba(16, 185, 129, 0.4)"
                : "rgba(239, 68, 68, 0.4)";
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(targetMidX, 140);
            ctx.lineTo(currentX, 140);
            ctx.setLineDash([10, 8]);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.shadowBlur = 0;

            ctx.font = "bold 16px Quicksand";
            ctx.fillStyle = arrowColor;
            ctx.textAlign = "center";
            const labelX2 = (targetMidX + currentX) / 2;
            const labelY2 = 140 + 30;

            // Label shows the operation being performed
            const text2 = `‚àí${num2}`;
            const textWidth2 = ctx.measureText(text2).width;
            ctx.fillStyle = "white";
            ctx.strokeStyle = arrowColor;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.roundRect(
              labelX2 - textWidth2 / 2 - 10,
              labelY2 - 18,
              textWidth2 + 20,
              28,
              14
            );
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = arrowColor;
            ctx.fillText(text2, labelX2, labelY2);

            const num2Direction = effectiveMovement >= 0 ? "right" : "left";
            drawArrowhead(currentX, 140, num2Direction, arrowColor);

            hasilDiv.style.display = "block";
            hasilDiv.textContent = `${num1} ‚àí (${num2}) = ${hasil}`;
            hasilDiv.classList.add("updated");
            setTimeout(() => hasilDiv.classList.remove("updated"), 600);

            if (secondProgress >= 1) {
              resultX = targetEndX;
              resultY = 100;
              drawResultMarker(targetEndX, 100, hasil);
              return;
            }
          }

          animationFrameId = requestAnimationFrame(animate);
        }

        animationFrameId = requestAnimationFrame(animate);
      }

      function showInstructions() {
        const modal = new bootstrap.Modal(
          document.getElementById("instructionModal")
        );
        modal.show();
      }

      function switchPage(page) {
        alert(`Fitur ${page} akan segera hadir! üåü‚ú®`);
      }
    </script>
  </body>
</html>
