<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pengurangan Bilangan Bulat 🌸✨</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@400;500;600;700&display=swap');
    </style>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <nav class="navbar navbar-expand-lg">
      <div class="container-fluid">
        <a class="navbar-brand" href="#">Pembelajaran Bilangan Bulat</a>
        <button
          class="navbar-toggler"
          type="button"
          data-bs-toggle="collapse"
          data-bs-target="#navbarNav"
          style="background: white; border-radius: 15px"
        >
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
          <ul class="navbar-nav ms-auto">
            <li class="nav-item">
              <a class="nav-link" href="index.html" data-transition="fade"
                >➕ Penjumlahan</a
              >
            </li>
            <li class="nav-item">
              <a
                class="nav-link active"
                href="pengurangan.html"
                data-transition="fade"
                >➖ Pengurangan</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link" href="perkalian.html" data-transition="fade"
                >✖️ Perkalian</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link" href="Interaktif1.html"
                >🧩 Interaktif Penjumlahan dan Pengurangan</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link" href="Interaktif2.html"
                >🕹️ Interaktif Perkalian</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link" href="game.html" data-transition="fade"
                >🎮 Permainan</a
              >
            </li>
          </ul>
        </div>
      </div>
    </nav>
    
    <div class="container my-5 content">
        <div class="text-center">
            <h1>Pengurangan Bilangan Bulat</h1>
        </div>
        
        <div class="input-group justify-content-center mb-4">
            <input type="number" id="num1" placeholder="Angka Pertama" class="form-control w-auto me-2" oninput="startAnimation()" style="max-width: 200px;">
            <div class="operator-box">−</div>
            <input type="number" id="num2" placeholder="Angka Kedua" class="form-control w-auto me-2" oninput="startAnimation()" style="max-width: 200px;">
            <button class="btn btn-info rounded-circle d-flex align-items-center justify-content-center" onclick="showInstructions()" title="Petunjuk" style="width: 50px; height: 50px;">
                💡
            </button>
        </div>
        
        <div class="card canvas-card mb-4">
            <div class="card-body p-0">
                <canvas id="garis" width="700" height="250"></canvas>
            </div>
        </div>
        
        <div id="hasil" class="alert alert-success text-center result-alert" role="alert" style="display: none;"></div>
    </div>

    <div id="instructionModal" class="modal fade" tabindex="-1">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Instruksi Penggunaan</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <p>
                        <b>🌸 Angka Pertama</b><br>
                        Menentukan titik awal pada garis bilangan.<br>
                        • Jika positif (+), bergerak ke kanan dari 0<br>
                        • Jika negatif (-), bergerak ke kiri dari 0<br><br>
                        
                        <b>💜 Angka Kedua</b><br>
                        Menentukan langkah berikutnya:<br>
                        • Jika positif (+), bergerak ke kiri dari angka pertama<br>
                        • Jika negatif (-), bergerak ke kanan dari angka pertama<br><br>
                        
                        <b>Note</b><br>
                        Misalkan a adalah bilangan bulat, maka -(-a) = a
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        const canvas = document.getElementById('garis');
        const ctx = canvas.getContext('2d');
        const hasilDiv = document.getElementById('hasil');
        let animationFrameId;
        const padding = 60;

        // Create tooltip element
        const tooltip = document.createElement("div");
        tooltip.className = "tooltip";
        tooltip.style.cssText = "position: absolute; background: linear-gradient(135deg, #9F7AEA, #805AD5); color: white; padding: 8px 15px; border-radius: 15px; font-size: 14px; font-weight: 600; pointer-events: none; opacity: 0; transition: opacity 0.2s; z-index: 9999; box-shadow: 0 4px 12px rgba(128, 90, 213, 0.4);";
        document.body.appendChild(tooltip);

        // Responsive canvas
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.offsetWidth - 40;
            canvas.height = 250;
            if (document.getElementById('num1').value || document.getElementById('num2').value) {
                startAnimation();
            }
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function drawNumberLine(minVal, maxVal, num1, num2, result) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const canvasWidth = canvas.width - 2 * padding;
            const ticks = [];
            
            // Always include 0, num1, and result
            ticks.push(0);
            ticks.push(num1);
            ticks.push(result);

            // Determine if we need to show detailed ticks around result
            const distanceFromNum1ToResult = Math.abs(result - num1);
            
            // Fine detail around result (always show ±3 around result)
            const fineStart = result - 3;
            const fineEnd = result + 3;
            for (let i = fineStart; i <= fineEnd; i++) {
                ticks.push(i);
            }

            // If distance is large, add intermediate milestones but skip numbers between num1 and result
            if (distanceFromNum1ToResult > 10) {
                // Add strategic points between 0 and num1 (if num1 is far from 0)
                if (Math.abs(num1) > 10) {
                    const step1 = Math.ceil(Math.abs(num1) / 5);
                    const direction1 = num1 > 0 ? 1 : -1;
                    for (let i = step1; Math.abs(i) < Math.abs(num1); i += step1) {
                        ticks.push(i * direction1);
                    }
                }
            } else {
                // If distance is small (≤10), show all integers between num1 and result
                const start = Math.min(num1, result);
                const end = Math.max(num1, result);
                for (let i = start; i <= end; i++) {
                    ticks.push(i);
                }
            }

            // Add buffer points for better visualization
            const allValues = [0, num1, result];
            const minValue = Math.min(...allValues);
            const maxValue = Math.max(...allValues);
            
            // Add edge points
            if (minValue < -3) {
                ticks.push(minValue - 2);
            }
            if (maxValue > 3) {
                ticks.push(maxValue + 2);
            }

            const uniqueTicks = [...new Set(ticks)].sort((a, b) => a - b);
            const tickSpacing = canvasWidth / (uniqueTicks.length - 1);

            const tickPositions = new Map();
            uniqueTicks.forEach((tick, index) => {
                const x = padding + index * tickSpacing;
                tickPositions.set(tick, x);
            });

            // Draw main gradient line
            const gradient = ctx.createLinearGradient(padding, 100, canvas.width - padding, 100);
            gradient.addColorStop(0, '#B794F4');
            gradient.addColorStop(0.5, '#9F7AEA');
            gradient.addColorStop(1, '#B794F4');
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.shadowColor = "rgba(159, 122, 234, 0.3)";
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.moveTo(padding, 100);
            ctx.lineTo(canvas.width - padding, 100);
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Draw ticks and numbers
            ctx.font = 'bold 14px Quicksand';
            ctx.fillStyle = '#9F7AEA';
            ctx.textAlign = 'center';
            
            uniqueTicks.forEach((tick, index) => {
                const x = padding + index * tickSpacing;
                if (x >= padding - 10 && x <= canvas.width - padding + 10) {
                    // Determine tick importance for styling
                    const isZero = tick === 0;
                    const isNum1 = tick === num1;
                    const isResult = tick === result;
                    const isNearResult = Math.abs(tick - result) <= 3;
                    
                    // Special styling based on importance
                    if (isZero) {
                        ctx.strokeStyle = '#9F7AEA';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(x, 85);
                        ctx.lineTo(x, 115);
                        ctx.stroke();
                        ctx.fillStyle = '#6B46C1';
                        ctx.font = 'bold 18px Quicksand';
                        ctx.fillText('0', x, 135);
                        ctx.font = 'bold 14px Quicksand';
                    } else if (isNum1 || isResult) {
                        // Important points (num1 and result)
                        ctx.strokeStyle = '#B794F4';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(x, 88);
                        ctx.lineTo(x, 112);
                        ctx.stroke();
                        ctx.fillStyle = '#805AD5';
                        ctx.font = 'bold 16px Quicksand';
                        ctx.fillText(tick, x, 135);
                        ctx.font = 'bold 14px Quicksand';
                    } else if (isNearResult) {
                        // Near result points
                        ctx.strokeStyle = '#D4B5F0';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x, 93);
                        ctx.lineTo(x, 107);
                        ctx.stroke();
                        ctx.fillStyle = '#9F7AEA';
                        ctx.fillText(tick, x, 135);
                    } else {
                        // Milestone points (far from result)
                        ctx.strokeStyle = '#E9D8FD';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x, 95);
                        ctx.lineTo(x, 105);
                        ctx.stroke();
                        ctx.fillStyle = '#C4B5D4';
                        ctx.font = 'bold 12px Quicksand';
                        ctx.fillText(tick, x, 135);
                        ctx.font = 'bold 14px Quicksand';
                    }
                }
            });

            // Draw arrow heads at ends
            drawArrowhead(canvas.width - padding, 100, "right", '#9F7AEA');
            drawArrowhead(padding, 100, "left", '#9F7AEA');

            return { tickPositions, uniqueTicks };
        }

        function drawArrowhead(x, y, direction, color) {
            ctx.fillStyle = color;
            ctx.shadowColor = "rgba(159, 122, 234, 0.3)";
            ctx.shadowBlur = 5;
            ctx.beginPath();
            ctx.moveTo(x, y);
            if (direction === "right") {
                ctx.lineTo(x - 10, y - 8);
                ctx.lineTo(x - 10, y + 8);
            } else {
                ctx.lineTo(x + 10, y - 8);
                ctx.lineTo(x + 10, y + 8);
            }
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawResultMarker(x, y, result) {
            ctx.shadowColor = "rgba(107, 70, 193, 0.5)";
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, 2 * Math.PI);
            ctx.fillStyle = '#6B46C1';
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Inner highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(x - 3, y - 3, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        let resultX, resultY, resultValue;
        
        canvas.addEventListener("mousemove", (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (resultX && Math.hypot(mouseX - resultX, mouseY - resultY) < 15) {
                tooltip.style.left = `${e.clientX + 10}px`;
                tooltip.style.top = `${e.clientY - 10}px`;
                tooltip.textContent = `Hasil: ${resultValue} ✨`;
                tooltip.style.opacity = "1";
            } else {
                tooltip.style.opacity = "0";
            }
        });

        canvas.addEventListener("mouseleave", () => {
            tooltip.style.opacity = "0";
        });

        function startAnimation() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            const num1 = parseInt(document.getElementById('num1').value) || 0;
            const num2 = parseInt(document.getElementById('num2').value) || 0;
            const hasil = num1 - num2; // PENGURANGAN

            resultValue = hasil;

            const values = [0, num1, hasil];
            const minVal = Math.min(...values) - 3;
            const maxVal = Math.max(...values) + 3;

            const { tickPositions, uniqueTicks } = drawNumberLine(minVal, maxVal, num1, num2, hasil);

            const startX = tickPositions.get(0) || padding;
            const targetMidX = tickPositions.get(num1) || (num1 >= 0 ? padding : canvas.width - padding);
            let targetEndX = tickPositions.get(hasil);

            if (targetEndX === undefined) {
                const sortedTicks = [...uniqueTicks].sort((a, b) => a - b);
                const index = sortedTicks.findIndex(tick => tick >= hasil);
                const prevTick = sortedTicks[index - 1] || sortedTicks[0];
                const nextTick = sortedTicks[index] || sortedTicks[sortedTicks.length - 1];
                const prevX = tickPositions.get(prevTick) || padding;
                const nextX = tickPositions.get(nextTick) || (nextTick >= 0 ? canvas.width - padding : padding);
                const ratio = (hasil - prevTick) / (nextTick - prevTick) || 1;
                targetEndX = prevX + (nextX - prevX) * ratio;
            }

            let currentX = startX;
            let midXReached = false;
            const animationDuration = 1200;
            let startTime;

            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = (timestamp - startTime) / animationDuration;

                drawNumberLine(minVal, maxVal, num1, num2, hasil);

                if (!midXReached) {
                    currentX = startX + (targetMidX - startX) * Math.min(progress, 1);
                    
                    // First arrow (num1)
                    ctx.strokeStyle = '#B794F4';
                    ctx.lineWidth = 5;
                    ctx.shadowColor = "rgba(183, 148, 244, 0.4)";
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.moveTo(startX, 60);
                    ctx.lineTo(currentX, 60);
                    ctx.setLineDash([10, 8]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.shadowBlur = 0;

                    // Label for num1
                    ctx.font = "bold 16px Quicksand";
                    ctx.fillStyle = '#B794F4';
                    ctx.textAlign = "center";
                    const labelX1 = (startX + currentX) / 2;
                    const labelY1 = 60 - 18;
                    
                    // Background bubble
                    const text1 = num1.toString();
                    const textWidth1 = ctx.measureText(text1).width;
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = '#B794F4';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.roundRect(labelX1 - textWidth1/2 - 10, labelY1 - 18, textWidth1 + 20, 28, 14);
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.fillStyle = '#B794F4';
                    ctx.fillText(text1, labelX1, labelY1);

                    const num1Direction = num1 >= 0 ? "right" : "left";
                    drawArrowhead(currentX, 60, num1Direction, '#B794F4');

                    if (progress >= 1) {
                        midXReached = true;
                        startTime = timestamp;
                        currentX = targetMidX;
                    }
                } else {
                    const secondProgress = (timestamp - startTime) / animationDuration;
                    currentX = targetMidX + (targetEndX - targetMidX) * Math.min(secondProgress, 1);

                    // First arrow stays
                    ctx.strokeStyle = '#B794F4';
                    ctx.lineWidth = 5;
                    ctx.shadowColor = "rgba(183, 148, 244, 0.4)";
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.moveTo(startX, 60);
                    ctx.lineTo(targetMidX, 60);
                    ctx.setLineDash([10, 8]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.shadowBlur = 0;

                    ctx.font = "bold 16px Quicksand";
                    ctx.fillStyle = '#B794F4';
                    ctx.textAlign = "center";
                    const labelX1 = (startX + targetMidX) / 2;
                    const labelY1 = 60 - 18;
                    
                    const text1 = num1.toString();
                    const textWidth1 = ctx.measureText(text1).width;
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = '#B794F4';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.roundRect(labelX1 - textWidth1/2 - 10, labelY1 - 18, textWidth1 + 20, 28, 14);
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.fillStyle = '#B794F4';
                    ctx.fillText(text1, labelX1, labelY1);

                    const num1Direction = num1 >= 0 ? "right" : "left";
                    drawArrowhead(targetMidX, 60, num1Direction, '#B794F4');

                    // Second arrow (SUBTRACTION: negative num2 means opposite direction)
                    // Subtracting positive = move left, subtracting negative = move right
                    const effectiveMovement = -num2; // Pengurangan membalik arah
                    const arrowColor = effectiveMovement >= 0 ? '#10B981' : '#EF4444';
                    
                    ctx.strokeStyle = arrowColor;
                    ctx.lineWidth = 5;
                    ctx.shadowColor = effectiveMovement >= 0 ? "rgba(16, 185, 129, 0.4)" : "rgba(239, 68, 68, 0.4)";
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.moveTo(targetMidX, 140);
                    ctx.lineTo(currentX, 140);
                    ctx.setLineDash([10, 8]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.shadowBlur = 0;

                    ctx.font = "bold 16px Quicksand";
                    ctx.fillStyle = arrowColor;
                    ctx.textAlign = "center";
                    const labelX2 = (targetMidX + currentX) / 2;
                    const labelY2 = 140 + 30;
                    
                    // Label shows the operation being performed
                    const text2 = `−${num2}`;
                    const textWidth2 = ctx.measureText(text2).width;
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = arrowColor;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.roundRect(labelX2 - textWidth2/2 - 10, labelY2 - 18, textWidth2 + 20, 28, 14);
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.fillStyle = arrowColor;
                    ctx.fillText(text2, labelX2, labelY2);

                    const num2Direction = effectiveMovement >= 0 ? "right" : "left";
                    drawArrowhead(currentX, 140, num2Direction, arrowColor);

                    hasilDiv.style.display = 'block';
                    hasilDiv.textContent = `${num1} − (${num2}) = ${hasil}`;
                    hasilDiv.classList.add("updated");
                    setTimeout(() => hasilDiv.classList.remove("updated"), 600);

                    if (secondProgress >= 1) {
                        resultX = targetEndX;
                        resultY = 100;
                        drawResultMarker(targetEndX, 100, hasil);
                        return;
                    }
                }

                animationFrameId = requestAnimationFrame(animate);
            }

            animationFrameId = requestAnimationFrame(animate);
        }

        function showInstructions() {
            const modal = new bootstrap.Modal(document.getElementById('instructionModal'));
            modal.show();
        }

        function switchPage(page) {
            alert(`Fitur ${page} akan segera hadir! 🌟✨`);
        }
    </script>
</body>
</html>